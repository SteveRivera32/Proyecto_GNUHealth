
{'role': 'system', 'content': 'You are an SQL expert specialized in the GNU Health database. You are part of an application system. Your job is to analyze natural language queries and return either an SQL query or a Markdown-formatted response, using strict JSON.\n\nYou must always respond in one of the following three valid JSON formats:\n\n---\n\n1. When the user query requires SQL execution:\n{"require": true, "sql": "SQL QUERY HERE"}\n\n- Only use this format when SQL is needed.\n- The query must be correct and based on the GNU Health schema.\n- Do not include explanations.\n- Do not wrap the output in code blocks or quotes.\n- Do NOT use Markdown outside.\n- Return only the JSON object.\n\n---\n\n2. When the user query does not require SQL:\n{"content": "RESPONSE IN MARKDOWN"}\n\n- Use this format to explain, clarify, or answer general questions.\n- Respond using Markdown inside the "content" field.\n- Always respond in the same language the user used.\n- Do not include SQL unless the user asked for it.\n- Do not explain unless requested.\n\nfew-shot-example:\nUserQuestion: puedes revisar cual es el tipo mas comun\n{content:"El analisi muestra que el tipo mas comun es......"}\n\n\n\n---\n\n3. When the SQL query you provided fails and the system returns an error:\n\n{"error": "ERROR MESSAGE HERE"}\n\n- This means your previous SQL query failed.\n- Analyze the error message and respond with either:\na) A corrected SQL query using {"require": true, "sql": "..."}\nb) A Markdown explanation using {"content": "..."} if the error cannot be resolved in SQL.\n- Never return the error message directly to the user.\n- Always follow the same language used by the user.\n- Never break JSON formatting.\n\nExecutedSQL: SELECT gp.name FROM gnuhealth_pathology as gpt LIMIT 50\nSQLError: missing FROM-clause entry for table "gp" Position: 8\n\nrespond:{"require":true, "sql":"SELECT gpt.name FROM gnuhealth_pathology as gpt LIMIT 50"}\n\n---\n\nQuery execution:\n\n- The database engine is PostgreSQL.\n- You do not execute SQL.\n- When you return {"require": true, "sql": "..."}, the system will run the query and return the result to you.\n- The result will be in the following format:\n\n    [\n    {"Column1": "Value1", "Column2": "Value2"},\n    {"Column1": "Value1", "Column2": "Value2"},\n    ...\n    ]\n\n- When you receive the result, respond using:\n{"content": "RESULT IN MARKDOWN"}\n\n- Format the result as a Markdown table if appropriate.\n- Do not generate a new SQL query.\n- Do not explain the data unless the user requested it.\n\n--\n\nParsing issues:\n\n- If you receive a query result that is malformed or cannot be parsed, do not respond with a generic message.\n- Instead, return the following format to signal a data parsing issue:\n\n{"parse_error": "Could not parse the query result. Please check the format or structure."}\n\n- This helps the application detect and handle data parsing errors.\n- Do not use the {"content": "..."} format for this case.\n\n---\n\nMultilingual behavior:\n\n- Match the language of the user in all responses.\n- If the user writes in Spanish, respond in Spanish.\n- If the user writes in English, respond in English.\n\n---\n\nStrict rules:\n\n- Never include reasoning, or extra commentary.\n- Never return invalid JSON.\n- Never return multiple formats at once.\n- Never include code blocks or quotes around the JSON.\n- Follow the context provided by the tables\n\nFew-Shot-Examples:\n\nUserQuestion: listar  las enfermedades \nrespond:{"require":true, "sql":"SELECT gnuhealth_pathology.name FROM gnuhealth_pathology LIMIT 50;"}\n\n\n\n\n\n'}
{'role': 'user', 'content': 'Dame un conteo de los casos de enfermedades que tenemos registrados en los pacientes activos y agrupalos por municipio dame un total de casos por municipio.'}
{'role': 'user', 'content': '\n    database context:\n     Table: gnuhealth_patient_disease\ntabla: gnuhealth_patient_disease\ndescripción: Registra los diagnósticos y enfermedades de cada paciente, incluyendo severidad, fechas relevantes, tratamiento, profesional tratante y metadatos clínicos (alergias, infecciosidad, estado, etc.).\n\n\nSe utiliza gnuhealth_patient_disease (gpd) como la tabla central, filtrando por gpd.is_active = TRUE para asegurar que solo se consideren diagnósticos activos.\n\nSe realiza un LEFT JOIN con gnuhealth_patient (gp) usando gpd.name = gp.id para obtener el nombre del paciente (patient_name).\n\nLuego, se hace otro LEFT JOIN con gnuhealth_pathology (gph) utilizando gpd.pathology = gph.id para obtener el nombre estandarizado de la enfermedad (disease_name).\n\nFinalmente, se usa COUNT(gpd.id) y GROUP BY gp.name, gph.name para contar cuántos diagnósticos de una enfermedad específica tiene cada paciente. El ORDER BY ayuda a organizar los resultados.\n\n\nUserQuestion:\n\n"Dame un recuento de este mes sobre las enefermedades registradas"\n\n"Lista los casos de enfermedades registradas"\n\n"realiza un conteo de las enfermedades regsitradas"\n\nRespond: {\n  "require": true,\n  "sql": "SELECT  gph.name AS "Enfermedad", COUNT(gpd.id) AS "total" FROM gnuhealth_patient_disease AS gpd LEFT JOIN gnuhealth_patient AS gp ON gpd.name = gp.id LEFT JOIN gnuhealth_pathology AS gph ON gpd.pathology = gph.id WHERE gpd.is_active = TRUE GROUP BY  gph.name ORDER BY  "total" DESC;"\n  "}\n\n\ncolumnas:\n  id: integer, clave primaria autoincremental\n  create_date: timestamp, fecha de creación del registro\n  write_date: timestamp, fecha de última modificación\n  create_uid: integer, ID del usuario que creó el registro\n  write_uid: integer, ID del usuario que modificó por última vez\n  treatment_description: varchar, descripción del tratamiento administrado\n  healed_date: date, fecha de curación o resolución de la enfermedad\n  pathology: integer, patología diagnosticada (FK a gnuhealth_pathology.id)\n  disease_severity: varchar, severidad de la enfermedad (leve, moderada, grave, etc.)\n  is_allergy: boolean, indica si se trata de una enfermedad alérgica\n  healthprof: integer, profesional de salud responsable (FK a gnuhealth_healthprofessional.id)\n  pregnancy_warning: boolean, advertencia si el diagnóstico afecta el embarazo\n  weeks_of_pregnancy: integer, semana de gestación en la que se contrajo la enfermedad\n  is_on_treatment: boolean, indica si el pacientetabla: gnuhealth_patient_disease\ndescripción: Registra los diagnósticos y enfermedades de cada paciente, incluyendo severidad, fechas relevantes, tratamiento, profesional tratante y metadatos clínicos (alergias, infecciosidad, estado, etc.).\n\n\n\n\n\ncolumnas:\n  id: integer, clave primaria autoincremental\n  create_date: timestamp, fecha de creación del registro\n  write_date: timestamp, fecha de última modificación\n  create_uid: integer, ID del usuario que creó el registro\n  write_uid: integer, ID del usuario que modificó por última vez\n  treatment_description: varchar, descripción del tratamiento administrado\n  healed_date: date, fecha de curación o resolución de la enfermedad\n  pathology: integer, patología diagnosticada (FK a gnuhealth_pathology.id)\n  disease_severity: varchar, severidad de la enfermedad (leve, moderada, grave, etc.)\n  is_allergy: boolean, indica si se trata de una enfermedad alérgica\n  healthprof: integer, profesional de salud responsable (FK a gnuhealth_healthprofessional.id)\n  pregnancy_warning: boolean, advertencia si el diagnóstico afecta el embarazo\n  weeks_of_pregnancy: integer, semana de gestación en la que se contrajo la enfermedad\n  is_on_treatment: boolean, indica si el paciente está actualmente en tratamiento\n  diagnosed_date: date, fecha de diagnóstico\n  extra_info: text, información adicional\n  status: varchar, estado del diagnóstico (activo, resuelto, crónico, etc.)\n  is_active: boolean, indica si la enfermedad está activa\n  date_stop_treatment: date, fecha de fin del tratamiento\n  pcs_code: integer, código de procedimiento (FK a gnuhealth_procedure.id)\n  is_infectious: boolean, indica si la enfermedad es infecciosa\n  allergy_type: varchar, tipo de alergia (alimentaria, medicamentosa, ambiental, etc.)\n  name: integer, paciente (FK a gnuhealth_patient.id)\n  age: integer, edad del paciente al momento del diagnóstico\n  date_start_treatment: date, fecha de inicio del tratamiento\n  short_comment: varchar, comentarios breves\n  newborn_id: integer, ID de recién nacido asociado (FK a gnuhealth_newborn.id)\n  institution: integer, institución de salud (FK a gnuhealth_institution.id)\n  lab_confirmed: boolean, confirmación de laboratorio\n  lab_test: integer, ID de la prueba de laboratorio asociada (FK a gnuhealth_lab.id)\n  est_dodx: boolean, diagnóstico estimado (no confirmado)\n\nllaves_foráneas:\n  pathology       → gnuhealth_pathology(id)\n  healthprof      → gnuhealth_healthprofessional(id)\n  pcs_code        → gnuhealth_procedure(id)\n  name            → gnuhealth_patient(id)\n  newborn_id      → gnuhealth_newborn(id)\n  institution     → gnuhealth_institution(id)\n  lab_test        → gnuhealth_lab(id)\n\níndices:\n  - clave primaria: id\n  - índice: allergy_type\n  - índice: disease_severity\n  - índice: status está actualmente en tratamiento\n  diagnosed_date: date, fecha de diagnóstico\n  extra_info: text, información adicional\n  status: varchar, estado del diagnóstico (activo, resuelto, crónico, etc.)\n  is_active: boolean, indica si la enfermedad está activa\n  date_stop_treatment: date, fecha de fin del tratamiento\n  pcs_code: integer, código de procedimiento (FK a gnuhealth_procedure.id)\n  is_infectious: boolean, indica si la enfermedad es infecciosa\n  allergy_type: varchar, tipo de alergia (alimentaria, medicamentosa, ambiental, etc.)\n  name: integer, paciente (FK a gnuhealth_patient.id)\n  age: integer, edad del paciente al momento del diagnóstico\n  date_start_treatment: date, fecha de inicio del tratamiento\n  short_comment: varchar, comentarios breves\n  newborn_id: integer, ID de recién nacido asociado (FK a gnuhealth_newborn.id)\n  institution: integer, institución de salud (FK a gnuhealth_institution.id)\n  lab_confirmed: boolean, confirmación de laboratorio\n  lab_test: integer, ID de la prueba de laboratorio asociada (FK a gnuhealth_lab.id)\n  est_dodx: boolean, diagnóstico estimado (no confirmado)\n\nllaves_foráneas:\n  pathology       → gnuhealth_pathology(id)\n  healthprof      → gnuhealth_healthprofessional(id)\n  pcs_code        → gnuhealth_procedure(id)\n  name            → gnuhealth_patient(id)\n  newborn_id      → gnuhealth_newborn(id)\n  institution     → gnuhealth_institution(id)\n  lab_test        → gnuhealth_lab(id)\n\níndices:\n  - clave primaria: id\n  - índice: allergy_type\n  - índice: disease_severity\n  - índice: status\n\n Table: gnuhealth_patient\ntabla: gnuhealth_patient\ndescripción: Contiene información médica, social, demográfica y de estilo de vida de los pacientes registrados en GNU Health.\n\nNOTA: Simpre que el usaurio pida realizar algun tipo de conteo asegurate de agrupar por campos relevanates.\n\nGuia de uso:\n\nAlgunas preguntas relacionadas a este documento son:\nEstado Activo: Siempre se debe verificar que el paciente esté activo. La tabla party_party contiene el campo active para esta verificación.\nInformación de Pacientes: La información principal de los pacientes se encuentra en gnuhealth_patient, vinculada a party_party por patient.name = party.id.\nCálculo de Edad: Para la edad, se requiere gnuhealth_patient, party_party y gnuhealth_birth_certificate.\nUbicación (Municipio/Ciudad/Lugar): La ubicación del paciente se obtiene a través de gnuhealth_du (descripción de la unidad de distribución) relacionada con party_party.du.\n\n\n\nPara obtener la ubciacion de un paciente (Municipio, vivienda) usa este SQL\nSQL: SELECT du.desc as "Municipio"  FROM gnuhealth_patient as patient LEFT JOIN party_party as party  on  patient.name = party.id\nLEFT JOIN gnuhealth_du as du ON party.du=du.id WHERE party.active=true\n\nPara saber si un apciente esta activo se ejecuta este SQL\nSQL: SELECT * FROM gnuhealth_patient AS patient LEFT JOIN party_party AS party ON patient.name = party.id WHERE party.active = TRUE;\n\nExplicacion de este query Esta consulta base es esencial para filtrar solo los registros de pacientes que están designados como activos en el sistema, utilizando la columna active de la tabla party_party.\n\nUserQuestion:\n\n"Listar la distribución de los casos por edad."\n"Mostrar un promedio de edad de los pacientes."\n"¿Cuál es la edad de los pacientes?"\nSQL de Promedio de Edad:\nrespond: {\n  "require": true,\n  "sql": "SELECT AVG(DATE_PART(\'year\', AGE(birth.dob))) AS promedio_edad FROM gnuhealth_patient AS patient LEFT JOIN party_party AS party ON patient.name = party.id LEFT JOIN gnuhealth_birth_certificate AS birth ON birth.name = party.id WHERE party.active = TRUE;"\n}\n\nSQL de Distribución por Edad (rangos/individual):\n{\n  "require": true,\n  "sql": "SELECT DATE_PART(\'year\', AGE(birth.dob)) AS edad, COUNT(patient.name) AS total_pacientes FROM gnuhealth_patient AS patient LEFT JOIN party_party AS party ON patient.name = party.id LEFT JOIN gnuhealth_birth_certificate AS birth ON birth.name = party.id WHERE party.active = TRUE GROUP BY edad ORDER BY edad;"\n}\nPara la edad, se usa la función DATE_PART(\'year\', AGE(birth.dob)) combinando gnuhealth_patient, party_party y gnuhealth_birth_certificate. El promedio usa AVG(), y la distribución se logra con COUNT() y GROUP BY sobre la edad calculada.\n\n\nUserQuestion:\n"Listar la distribución de los pacientes por (sexo, género, mujer y hombre)."\n\nrespond:{\n  "require": true,\n  "sql": "SELECT party.gender, COUNT(patient.name) AS total_pacientes FROM gnuhealth_patient AS patient LEFT JOIN party_party AS party ON patient.name = party.id WHERE party.active = TRUE GROUP BY party.gender;"\n}\nEsta consulta utiliza COUNT() y GROUP BY sobre el campo party.gender de la tabla party_party para agrupar y contar pacientes por su género. La condición party.active = TRUE asegura la inclusión solo de pacientes activos.\n\n\nUserQuestion: \n- Muéstrame el recuento de casos de enfermedades por condición de salud (agrupando \'diabetes\' y sus variantes) desglosado por género (masculino y femenino), incluyendo solo pacientes activos. Ordena por el total de casos.",\n- Lista un conteo de las enfermedades y su dstirbucion por( sexo,genero, hombre y mujer)\nrespond:{\n    "require": true,\n    "sql": "SELECT CASE WHEN LOWER(gp.name) LIKE \'%diabetes%\' THEN \'Diabetes\' ELSE gp.name END AS condicion_salud, COUNT(CASE WHEN pp.gender = \'m\' THEN 1 END) AS masculino, COUNT(CASE WHEN pp.gender = \'f\' THEN 1 END) AS femenino, COUNT(gpd.id) AS total_casos FROM gnuhealth_patient_disease AS gpd JOIN gnuhealth_pathology AS gp ON gpd.pathology = gp.id JOIN gnuhealth_patient AS ghp ON gpd.name = ghp.id JOIN party_party AS pp ON ghp.name = pp.id WHERE pp.active = TRUE GROUP BY condicion_salud ORDER BY total_casos DESC;"\n}\n  "Explicacion": "Esta consulta agrupa los diagnósticos de enfermedades. Utiliza un `CASE` para normalizar todas las variantes de \'diabetes\' a una sola categoría \'Diabetes\'. Luego, cuenta los casos para hombres y mujeres por separado usando `COUNT(CASE WHEN ... THEN 1 END)`, y un conteo total de casos por cada condición. Se unen las tablas `gnuhealth_patient_disease`, `gnuhealth_pathology`, `gnuhealth_patient` y `party_party`. La condición `pp.active = TRUE` asegura que solo se consideren pacientes activos. Los resultados se agrupan por la condición de salud y se ordenan por el total de casos de forma descendente."\n\n\n\ncolumnas:\n  id: integer, clave primaria autoincremental\n  create_date: timestamp, fecha de creación del registro\n  write_date: timestamp, fecha de última modificación\n  create_uid: integer, ID del usuario que creó el registro\n  write_uid: integer, ID del usuario que modificó por última vez\n  family: integer, ID de la familia del paciente (FK a gnuhealth_family.id)\n  blood_type: varchar, tipo de sangre del paciente\n  general_info: text, información médica general\n  primary_care_doctor: integer, médico de cabecera (FK a gnuhealth_healthprofessional.id)\n  critical_info: text, información crítica adicional\n  rh: varchar, factor Rh del paciente\n  current_address: integer, dirección temporal (FK a party_address.id)\n  name: integer, ID del paciente (FK a party_party.id)\n  dod: timestamp, fecha de fallecimiento\n  current_insurance: integer, aseguradora actual (FK a gnuhealth_insurance.id)\n  cod: integer, causa de muerte (FK a gnuhealth_pathology.id)\n  deceased: boolean, indica si el paciente ha fallecido\n  works_at_home: boolean, indica si trabaja desde casa\n  prison_current: boolean, indica si está actualmente en prisión\n  domestic_violence: boolean, ha sido víctima de violencia doméstica\n  hostile_area: boolean, vive en zona de riesgo o conflicto\n  sexual_abuse: boolean, ha sufrido abuso sexual\n  hours_outside: integer, horas promedio fuera del hogar por día\n  drug_addiction: boolean, adicción activa a drogas\n  school_withdrawal: boolean, abandono escolar\n  income: varchar, nivel de ingresos del paciente\n  single_parent: boolean, vive en familia monoparental\n  ses_notes: text, notas adicionales sobre situación socioeconómica\n\nllaves_foráneas:\n  family → gnuhealth_family(id)\n  primary_care_doctor → gnuhealth_healthprofessional(id)\n  current_address → party_address(id)\n  name → party_party(id)\n  current_insurance → gnuhealth_insurance(id)\n  cod → gnuhealth_pathology(id)\n  diet_belief → gnuhealth_diet_belief(id)\n  vegetarian_type → gnuhealth_vegetarian_types(id)\n\níndices:\n  - clave primaria: id\n  - única: name\n  - índice adicional: active\n\n Table: party_party\ntabla: party_party\ndescripción: Contiene la información básica de entidades dentro del sistema (personas, instituciones, pacientes, profesionales de salud, aseguradoras, etc.), actuando como base para identificar a cada parte involucrada en procesos clínicos, administrativos o logísticos.\n\ncolumnas:\n  id: integer, clave primaria autoincremental\n  create_date: timestamp, fecha de creación del registro\n  write_date: timestamp, fecha de última modificación\n  create_uid: integer, ID del usuario que creó el registro\n  write_uid: integer, ID del usuario que modificó por última vez\n  code: varchar, código único asignado a la entidad\n  code_length: integer, longitud del código (útil para validaciones)\n  active: boolean, indica si la entidad está activa\n  name: varchar, nombre o denominación principal\n  photo: bytea, fotografía o imagen de la entidad\n  alternative_identification: boolean, si tiene identificaciones alternativas\n  is_healthprof: boolean, indica si es un profesional de la salud\n  insurance_company_type: varchar, tipo de aseguradora si aplica\n  internal_user: integer, usuario interno del sistema (FK a res_user.id)\n  activation_date: date, fecha de activación de la entidad\n  citizenship: integer, país de ciudadanía (FK a country_country.id)\n  is_patient: boolean, indica si es un paciente\n  is_insurance_company: boolean, indica si es una aseguradora\n  ref: varchar, identificador único de persona (PUID)\n  lastname: varchar, apellidos (en caso de personas)\n  ethnic_group: integer, grupo étnico (FK a gnuhealth_ethnicity.id)\n  du: integer, documento único (FK a gnuhealth_du.id)\n  unidentified: boolean, indica si la persona es no identificada\n  dob: date, fecha de nacimiento\n  is_institution: boolean, si es una institución\n  marital_status: varchar, estado civil\n  gender: varchar, género (masculino, femenino, otro)\n  is_pharmacy: boolean, si representa a una farmacia\n  residence: integer, país o lugar de residencia (FK a country_country.id)\n  is_person: boolean, indica si es una persona física\n  education: varchar, nivel educativo\n  occupation: integer, ocupación (FK a gnuhealth_occupation.id)\n  warehouse: integer, almacén asociado (FK a stock_location.id)\n  death_certificate: integer, certificado de defunción (FK a gnuhealth_death_certificate.id)\n  birth_certificate: integer, certificado de nacimiento (FK a gnuhealth_birth_certificate.id)\n  deceased: boolean, si está fallecido\n  name_representation: varchar, nombre en forma alternativa\n  replaced_by: integer, ID de reemplazo (FK a party_party.id)\n  federation_account: varchar, identificador de federación (para interoperabilidad)\n  fed_country: varchar, país de federación\n  fsync: boolean, usado para sincronización federada\n  est_dob: boolean, fecha de nacimiento estimada\n  est_years: integer, edad estimada en años\n  create_target: boolean, indica si debe crearse como objetivo (útil para integración)\n\nllaves_foráneas:\n  internal_user       → res_user(id)\n  citizenship         → country_country(id)\n  ethnic_group        → gnuhealth_ethnicity(id)\n  du                  → gnuhealth_du(id)\n  residence           → country_country(id)\n  occupation          → gnuhealth_occupation(id)\n  warehouse           → stock_location(id)\n  death_certificate   → gnuhealth_death_certificate(id)\n  birth_certificate   → gnuhealth_birth_certificate(id)\n  replaced_by         → party_party(id)\n\níndices:\n  - clave primaria: id\n  - únicos: federation_account, internal_user, ref, code\n  - índices: code, code_length, insurance_company_type, name\n\n\n Table: gnuhealth_pathology\ntabla: gnuhealth_pathology\ndescripción: Catálogo de enfermedades o condiciones médicas. Contiene información estandarizada como el código, nombre, clasificación genética y categoría principal, usada para registrar diagnósticos en los pacientes.\n\nConsideraciones Clave Adicionales para gnuhealth_pathology\nCatálogo de Patologías: La tabla gnuhealth_pathology es un catálogo de todas las posibles enfermedades o condiciones médicas que se pueden diagnosticar.\n\nVínculo con gnuhealth_patient_disease: El campo pathology en gnuhealth_patient_disease es una clave foránea que apunta a gnuhealth_pathology.id. Esto significa que cada registro de diagnóstico de paciente (gnuhealth_patient_disease) está vinculado a una definición de enfermedad (gnuhealth_pathology).\n\nInformación Estandarizada: gnuhealth_pathology contiene el code y name estandarizados de las enfermedades, lo cual es útil para listar o agrupar diagnósticos por su nombre oficial. También tiene un campo active para indicar si la patología está en uso.\n\ncolumnas:\n  id: integer, clave primaria autoincremental\n  create_date: timestamp, fecha de creación del registro\n  write_date: timestamp, fecha de última modificación\n  create_uid: integer, ID del usuario que creó el registro\n  write_uid: integer, ID del usuario que modificó por última vez\n  category: integer, categoría principal de la enfermedad (FK a gnuhealth_pathology_category.id)\n  code: varchar, código de la enfermedad (puede ser estándar como CIE-10, SNOMED, etc.)\n  name: varchar, nombre de la enfermedad o condición\n  info: text, información adicional\n  protein: varchar, proteína relacionada (si aplica)\n  gene: varchar, gen relacionado (si aplica)\n  chromosome: varchar, cromosoma afectado (si aplica)\n  active: boolean, indica si la patología está activa y disponible para ser usada\n  uri: varchar, enlace o identificador externo (por ejemplo, en bases de datos médicas)\n\nllaves_foráneas:\n  category → gnuhealth_pathology_category(id)\n\níndices:\n  - clave primaria: id\n  - índice único: code\n  - índice: active\n\n\n Table: gnuhealth_du\ntabla: gnuhealth_du\ndescripción: Esta tabla contiene información detallada sobre las unidades de vivienda registradas, incluyendo características físicas de la propiedad, ubicación geográfica, servicios básicos disponibles y otros datos sociodemográficos relevantes.\n\ncolumnas:\n  id: integer, clave primaria autoincremental\n  create_date: timestamp, fecha de creación del registro\n  write_date: timestamp, fecha de última modificación\n  create_uid: integer, ID del usuario que creó el registro (FK a res_user.id)\n  write_uid: integer, ID del usuario que modificó por última vez el registro (FK a res_user.id)\n  bathrooms: integer, número de baños en la vivienda\n  roof_type: varchar, tipo de techo (ej. teja, lámina, concreto)\n  urladdr: varchar, enlace al mapa u otro recurso geográfico (ej. OpenStreetMap)\n  sewers: boolean, indica si la vivienda tiene acceso a red de alcantarillado\n  dwelling: varchar, tipo de vivienda (ej. casa, apartamento)\n  address_street_number: varchar, número del inmueble en la calle \n  address_country: integer, país (FK a gcountry_country.id)\n  address_street: varchar, nombre de la calle\n  electricity: boolean, indica si cuenta con suministro eléctrico\n  address_subdivision: integer, subdivisión administrativa (FK a country_subdivision.id)\n  housing: varchar, condiciones o estado de la vivienda\n  address_district: varchar, distrito al que pertenece\n  materials: varchar, materiales predominantes de construcción\n  internet: boolean, indica si cuenta con acceso a internet\n  latitude: numeric, coordenada de latitud de la vivienda\n  address_zip: varchar, código postal\n  picture: bytea, imagen o fotografía asociada a la vivienda\n  address_street_bis: varchar, información adicional del domicilio (bis, etc.)\n  bedrooms: integer, cantidad de dormitorios\n  gas: boolean, indica si tiene acceso a suministro de gas\n  television: boolean, indica si cuenta con televisión\n  telephone: boolean, indica si tiene línea telefónica\n  water: boolean, acceso a agua potable o red pública\n  total_surface: integer, superficie total de la vivienda (en metros cuadrados)\n  desc: varchar, descripción general de la vivienda\n  address_city: varchar, ciudad donde se ubica la vivienda\n  operational_sector: integer, sector operativo asignado (FK a gnuhealth_operational_sector.id)\n  name: varchar, identificador único o código de la vivienda\n  trash: boolean, indica si cuenta con servicio de recolección de basura\n  longitude: numeric, coordenada de longitud\n  address_municipality: varchar, municipio correspondiente\n  altitude: integer, altitud sobre el nivel del mar\n\nllaves_foráneas:\n  address_country     → gcountry_country(id)\n  address_subdivision → country_subdivision(id)\n  operational_sector  → gnuhealth_operational_sector(id)\n\níndices:\n  - clave primaria: id\n  - índices únicos: name\n    \nUserQuestion:Dame un conteo de los casos de enfermedades que tenemos registrados en los pacientes activos y agrupalos por municipio dame un total de casos por municipio.'}
role='assistant' content='```json\n{\n  "require": true,\n  "sql": "SELECT d.desc AS municipio, COUNT(gpd.id) AS total_casos FROM gnuhealth_patient_disease AS gpd JOIN gnuhealth_patient AS gp ON gpd.name = gp.id JOIN party_party AS pp ON gp.name = pp.id JOIN gnuhealth_du AS d ON pp.du = d.id WHERE gpd.is_active = TRUE GROUP BY municipio ORDER BY total_casos DESC;"\n}\n```' thinking=None images=None tool_calls=None
{'role': 'system', 'content': 'You are an SQL expert specialized in the GNU Health database. You are part of an application system. Your job is to analyze natural language queries and return either an SQL query or a Markdown-formatted response, using strict JSON.\n\nYou must always respond in one of the following three valid JSON formats:\n\n---\n\n1. When the user query requires SQL execution:\n{"require": true, "sql": "SQL QUERY HERE"}\n\n- Only use this format when SQL is needed.\n- The query must be correct and based on the GNU Health schema.\n- Do not include explanations.\n- Do not wrap the output in code blocks or quotes.\n- Do NOT use Markdown outside.\n- Return only the JSON object.\n\n---\n\n2. When the user query does not require SQL:\n{"content": "RESPONSE IN MARKDOWN"}\n\n- Use this format to explain, clarify, or answer general questions.\n- Respond using Markdown inside the "content" field.\n- Always respond in the same language the user used.\n- Do not include SQL unless the user asked for it.\n- Do not explain unless requested.\n\nfew-shot-example:\nUserQuestion: puedes revisar cual es el tipo mas comun\n{content:"El analisi muestra que el tipo mas comun es......"}\n\n\n\n---\n\n3. When the SQL query you provided fails and the system returns an error:\n\n{"error": "ERROR MESSAGE HERE"}\n\n- This means your previous SQL query failed.\n- Analyze the error message and respond with either:\na) A corrected SQL query using {"require": true, "sql": "..."}\nb) A Markdown explanation using {"content": "..."} if the error cannot be resolved in SQL.\n- Never return the error message directly to the user.\n- Always follow the same language used by the user.\n- Never break JSON formatting.\n\nExecutedSQL: SELECT gp.name FROM gnuhealth_pathology as gpt LIMIT 50\nSQLError: missing FROM-clause entry for table "gp" Position: 8\n\nrespond:{"require":true, "sql":"SELECT gpt.name FROM gnuhealth_pathology as gpt LIMIT 50"}\n\n---\n\nQuery execution:\n\n- The database engine is PostgreSQL.\n- You do not execute SQL.\n- When you return {"require": true, "sql": "..."}, the system will run the query and return the result to you.\n- The result will be in the following format:\n\n    [\n    {"Column1": "Value1", "Column2": "Value2"},\n    {"Column1": "Value1", "Column2": "Value2"},\n    ...\n    ]\n\n- When you receive the result, respond using:\n{"content": "RESULT IN MARKDOWN"}\n\n- Format the result as a Markdown table if appropriate.\n- Do not generate a new SQL query.\n- Do not explain the data unless the user requested it.\n\n--\n\nParsing issues:\n\n- If you receive a query result that is malformed or cannot be parsed, do not respond with a generic message.\n- Instead, return the following format to signal a data parsing issue:\n\n{"parse_error": "Could not parse the query result. Please check the format or structure."}\n\n- This helps the application detect and handle data parsing errors.\n- Do not use the {"content": "..."} format for this case.\n\n---\n\nMultilingual behavior:\n\n- Match the language of the user in all responses.\n- If the user writes in Spanish, respond in Spanish.\n- If the user writes in English, respond in English.\n\n---\n\nStrict rules:\n\n- Never include reasoning, or extra commentary.\n- Never return invalid JSON.\n- Never return multiple formats at once.\n- Never include code blocks or quotes around the JSON.\n- Follow the context provided by the tables\n\nFew-Shot-Examples:\n\nUserQuestion: listar  las enfermedades \nrespond:{"require":true, "sql":"SELECT gnuhealth_pathology.name FROM gnuhealth_pathology LIMIT 50;"}\n\n\n\n\n\n'}
{'role': 'user', 'content': 'Listame un conteo de las enfermedades registradas en los pacietnes, agrupalas por municipio y enfermedad. muestrame un total por municpio y enfermedad.'}
{'role': 'user', 'content': '\n    database context:\n     Table: gnuhealth_patient\ntabla: gnuhealth_patient\ndescripción: Contiene información médica, social, demográfica y de estilo de vida de los pacientes registrados en GNU Health.\n\nNOTA: Simpre que el usaurio pida realizar algun tipo de conteo asegurate de agrupar por campos relevanates.\n\nGuia de uso:\n\nAlgunas preguntas relacionadas a este documento son:\nEstado Activo: Siempre se debe verificar que el paciente esté activo. La tabla party_party contiene el campo active para esta verificación.\nInformación de Pacientes: La información principal de los pacientes se encuentra en gnuhealth_patient, vinculada a party_party por patient.name = party.id.\nCálculo de Edad: Para la edad, se requiere gnuhealth_patient, party_party y gnuhealth_birth_certificate.\nUbicación (Municipio/Ciudad/Lugar): La ubicación del paciente se obtiene a través de gnuhealth_du (descripción de la unidad de distribución) relacionada con party_party.du.\n\n\n\nPara obtener la ubciacion de un paciente (Municipio, vivienda) usa este SQL\nSQL: SELECT du.desc as "Municipio"  FROM gnuhealth_patient as patient LEFT JOIN party_party as party  on  patient.name = party.id\nLEFT JOIN gnuhealth_du as du ON party.du=du.id WHERE party.active=true\n\nPara saber si un apciente esta activo se ejecuta este SQL\nSQL: SELECT * FROM gnuhealth_patient AS patient LEFT JOIN party_party AS party ON patient.name = party.id WHERE party.active = TRUE;\n\nExplicacion de este query Esta consulta base es esencial para filtrar solo los registros de pacientes que están designados como activos en el sistema, utilizando la columna active de la tabla party_party.\n\nUserQuestion:\n\n"Listar la distribución de los casos por edad."\n"Mostrar un promedio de edad de los pacientes."\n"¿Cuál es la edad de los pacientes?"\nSQL de Promedio de Edad:\nrespond: {\n  "require": true,\n  "sql": "SELECT AVG(DATE_PART(\'year\', AGE(birth.dob))) AS promedio_edad FROM gnuhealth_patient AS patient LEFT JOIN party_party AS party ON patient.name = party.id LEFT JOIN gnuhealth_birth_certificate AS birth ON birth.name = party.id WHERE party.active = TRUE;"\n}\n\nSQL de Distribución por Edad (rangos/individual):\n{\n  "require": true,\n  "sql": "SELECT DATE_PART(\'year\', AGE(birth.dob)) AS edad, COUNT(patient.name) AS total_pacientes FROM gnuhealth_patient AS patient LEFT JOIN party_party AS party ON patient.name = party.id LEFT JOIN gnuhealth_birth_certificate AS birth ON birth.name = party.id WHERE party.active = TRUE GROUP BY edad ORDER BY edad;"\n}\nPara la edad, se usa la función DATE_PART(\'year\', AGE(birth.dob)) combinando gnuhealth_patient, party_party y gnuhealth_birth_certificate. El promedio usa AVG(), y la distribución se logra con COUNT() y GROUP BY sobre la edad calculada.\n\n\nUserQuestion:\n"Listar la distribución de los pacientes por (sexo, género, mujer y hombre)."\n\nrespond:{\n  "require": true,\n  "sql": "SELECT party.gender, COUNT(patient.name) AS total_pacientes FROM gnuhealth_patient AS patient LEFT JOIN party_party AS party ON patient.name = party.id WHERE party.active = TRUE GROUP BY party.gender;"\n}\nEsta consulta utiliza COUNT() y GROUP BY sobre el campo party.gender de la tabla party_party para agrupar y contar pacientes por su género. La condición party.active = TRUE asegura la inclusión solo de pacientes activos.\n\n\nUserQuestion: \n- Muéstrame el recuento de casos de enfermedades por condición de salud (agrupando \'diabetes\' y sus variantes) desglosado por género (masculino y femenino), incluyendo solo pacientes activos. Ordena por el total de casos.",\n- Lista un conteo de las enfermedades y su dstirbucion por( sexo,genero, hombre y mujer)\nrespond:{\n    "require": true,\n    "sql": "SELECT CASE WHEN LOWER(gp.name) LIKE \'%diabetes%\' THEN \'Diabetes\' ELSE gp.name END AS condicion_salud, COUNT(CASE WHEN pp.gender = \'m\' THEN 1 END) AS masculino, COUNT(CASE WHEN pp.gender = \'f\' THEN 1 END) AS femenino, COUNT(gpd.id) AS total_casos FROM gnuhealth_patient_disease AS gpd JOIN gnuhealth_pathology AS gp ON gpd.pathology = gp.id JOIN gnuhealth_patient AS ghp ON gpd.name = ghp.id JOIN party_party AS pp ON ghp.name = pp.id WHERE pp.active = TRUE GROUP BY condicion_salud ORDER BY total_casos DESC;"\n}\n  "Explicacion": "Esta consulta agrupa los diagnósticos de enfermedades. Utiliza un `CASE` para normalizar todas las variantes de \'diabetes\' a una sola categoría \'Diabetes\'. Luego, cuenta los casos para hombres y mujeres por separado usando `COUNT(CASE WHEN ... THEN 1 END)`, y un conteo total de casos por cada condición. Se unen las tablas `gnuhealth_patient_disease`, `gnuhealth_pathology`, `gnuhealth_patient` y `party_party`. La condición `pp.active = TRUE` asegura que solo se consideren pacientes activos. Los resultados se agrupan por la condición de salud y se ordenan por el total de casos de forma descendente."\n\n\n\ncolumnas:\n  id: integer, clave primaria autoincremental\n  create_date: timestamp, fecha de creación del registro\n  write_date: timestamp, fecha de última modificación\n  create_uid: integer, ID del usuario que creó el registro\n  write_uid: integer, ID del usuario que modificó por última vez\n  family: integer, ID de la familia del paciente (FK a gnuhealth_family.id)\n  blood_type: varchar, tipo de sangre del paciente\n  general_info: text, información médica general\n  primary_care_doctor: integer, médico de cabecera (FK a gnuhealth_healthprofessional.id)\n  critical_info: text, información crítica adicional\n  rh: varchar, factor Rh del paciente\n  current_address: integer, dirección temporal (FK a party_address.id)\n  name: integer, ID del paciente (FK a party_party.id)\n  dod: timestamp, fecha de fallecimiento\n  current_insurance: integer, aseguradora actual (FK a gnuhealth_insurance.id)\n  cod: integer, causa de muerte (FK a gnuhealth_pathology.id)\n  deceased: boolean, indica si el paciente ha fallecido\n  works_at_home: boolean, indica si trabaja desde casa\n  prison_current: boolean, indica si está actualmente en prisión\n  domestic_violence: boolean, ha sido víctima de violencia doméstica\n  hostile_area: boolean, vive en zona de riesgo o conflicto\n  sexual_abuse: boolean, ha sufrido abuso sexual\n  hours_outside: integer, horas promedio fuera del hogar por día\n  drug_addiction: boolean, adicción activa a drogas\n  school_withdrawal: boolean, abandono escolar\n  income: varchar, nivel de ingresos del paciente\n  single_parent: boolean, vive en familia monoparental\n  ses_notes: text, notas adicionales sobre situación socioeconómica\n\nllaves_foráneas:\n  family → gnuhealth_family(id)\n  primary_care_doctor → gnuhealth_healthprofessional(id)\n  current_address → party_address(id)\n  name → party_party(id)\n  current_insurance → gnuhealth_insurance(id)\n  cod → gnuhealth_pathology(id)\n  diet_belief → gnuhealth_diet_belief(id)\n  vegetarian_type → gnuhealth_vegetarian_types(id)\n\níndices:\n  - clave primaria: id\n  - única: name\n  - índice adicional: active\n\n Table: gnuhealth_patient_disease\ntabla: gnuhealth_patient_disease\ndescripción: Registra los diagnósticos y enfermedades de cada paciente, incluyendo severidad, fechas relevantes, tratamiento, profesional tratante y metadatos clínicos (alergias, infecciosidad, estado, etc.).\n\n\nSe utiliza gnuhealth_patient_disease (gpd) como la tabla central, filtrando por gpd.is_active = TRUE para asegurar que solo se consideren diagnósticos activos.\n\nSe realiza un LEFT JOIN con gnuhealth_patient (gp) usando gpd.name = gp.id para obtener el nombre del paciente (patient_name).\n\nLuego, se hace otro LEFT JOIN con gnuhealth_pathology (gph) utilizando gpd.pathology = gph.id para obtener el nombre estandarizado de la enfermedad (disease_name).\n\nFinalmente, se usa COUNT(gpd.id) y GROUP BY gp.name, gph.name para contar cuántos diagnósticos de una enfermedad específica tiene cada paciente. El ORDER BY ayuda a organizar los resultados.\n\n\nUserQuestion:\n\n"Dame un recuento de este mes sobre las enefermedades registradas"\n\n"Lista los casos de enfermedades registradas"\n\n"realiza un conteo de las enfermedades regsitradas"\n\nRespond: {\n  "require": true,\n  "sql": "SELECT  gph.name AS "Enfermedad", COUNT(gpd.id) AS "total" FROM gnuhealth_patient_disease AS gpd LEFT JOIN gnuhealth_patient AS gp ON gpd.name = gp.id LEFT JOIN gnuhealth_pathology AS gph ON gpd.pathology = gph.id WHERE gpd.is_active = TRUE GROUP BY  gph.name ORDER BY  "total" DESC;"\n  "}\n\n\ncolumnas:\n  id: integer, clave primaria autoincremental\n  create_date: timestamp, fecha de creación del registro\n  write_date: timestamp, fecha de última modificación\n  create_uid: integer, ID del usuario que creó el registro\n  write_uid: integer, ID del usuario que modificó por última vez\n  treatment_description: varchar, descripción del tratamiento administrado\n  healed_date: date, fecha de curación o resolución de la enfermedad\n  pathology: integer, patología diagnosticada (FK a gnuhealth_pathology.id)\n  disease_severity: varchar, severidad de la enfermedad (leve, moderada, grave, etc.)\n  is_allergy: boolean, indica si se trata de una enfermedad alérgica\n  healthprof: integer, profesional de salud responsable (FK a gnuhealth_healthprofessional.id)\n  pregnancy_warning: boolean, advertencia si el diagnóstico afecta el embarazo\n  weeks_of_pregnancy: integer, semana de gestación en la que se contrajo la enfermedad\n  is_on_treatment: boolean, indica si el pacientetabla: gnuhealth_patient_disease\ndescripción: Registra los diagnósticos y enfermedades de cada paciente, incluyendo severidad, fechas relevantes, tratamiento, profesional tratante y metadatos clínicos (alergias, infecciosidad, estado, etc.).\n\n\n\n\n\ncolumnas:\n  id: integer, clave primaria autoincremental\n  create_date: timestamp, fecha de creación del registro\n  write_date: timestamp, fecha de última modificación\n  create_uid: integer, ID del usuario que creó el registro\n  write_uid: integer, ID del usuario que modificó por última vez\n  treatment_description: varchar, descripción del tratamiento administrado\n  healed_date: date, fecha de curación o resolución de la enfermedad\n  pathology: integer, patología diagnosticada (FK a gnuhealth_pathology.id)\n  disease_severity: varchar, severidad de la enfermedad (leve, moderada, grave, etc.)\n  is_allergy: boolean, indica si se trata de una enfermedad alérgica\n  healthprof: integer, profesional de salud responsable (FK a gnuhealth_healthprofessional.id)\n  pregnancy_warning: boolean, advertencia si el diagnóstico afecta el embarazo\n  weeks_of_pregnancy: integer, semana de gestación en la que se contrajo la enfermedad\n  is_on_treatment: boolean, indica si el paciente está actualmente en tratamiento\n  diagnosed_date: date, fecha de diagnóstico\n  extra_info: text, información adicional\n  status: varchar, estado del diagnóstico (activo, resuelto, crónico, etc.)\n  is_active: boolean, indica si la enfermedad está activa\n  date_stop_treatment: date, fecha de fin del tratamiento\n  pcs_code: integer, código de procedimiento (FK a gnuhealth_procedure.id)\n  is_infectious: boolean, indica si la enfermedad es infecciosa\n  allergy_type: varchar, tipo de alergia (alimentaria, medicamentosa, ambiental, etc.)\n  name: integer, paciente (FK a gnuhealth_patient.id)\n  age: integer, edad del paciente al momento del diagnóstico\n  date_start_treatment: date, fecha de inicio del tratamiento\n  short_comment: varchar, comentarios breves\n  newborn_id: integer, ID de recién nacido asociado (FK a gnuhealth_newborn.id)\n  institution: integer, institución de salud (FK a gnuhealth_institution.id)\n  lab_confirmed: boolean, confirmación de laboratorio\n  lab_test: integer, ID de la prueba de laboratorio asociada (FK a gnuhealth_lab.id)\n  est_dodx: boolean, diagnóstico estimado (no confirmado)\n\nllaves_foráneas:\n  pathology       → gnuhealth_pathology(id)\n  healthprof      → gnuhealth_healthprofessional(id)\n  pcs_code        → gnuhealth_procedure(id)\n  name            → gnuhealth_patient(id)\n  newborn_id      → gnuhealth_newborn(id)\n  institution     → gnuhealth_institution(id)\n  lab_test        → gnuhealth_lab(id)\n\níndices:\n  - clave primaria: id\n  - índice: allergy_type\n  - índice: disease_severity\n  - índice: status está actualmente en tratamiento\n  diagnosed_date: date, fecha de diagnóstico\n  extra_info: text, información adicional\n  status: varchar, estado del diagnóstico (activo, resuelto, crónico, etc.)\n  is_active: boolean, indica si la enfermedad está activa\n  date_stop_treatment: date, fecha de fin del tratamiento\n  pcs_code: integer, código de procedimiento (FK a gnuhealth_procedure.id)\n  is_infectious: boolean, indica si la enfermedad es infecciosa\n  allergy_type: varchar, tipo de alergia (alimentaria, medicamentosa, ambiental, etc.)\n  name: integer, paciente (FK a gnuhealth_patient.id)\n  age: integer, edad del paciente al momento del diagnóstico\n  date_start_treatment: date, fecha de inicio del tratamiento\n  short_comment: varchar, comentarios breves\n  newborn_id: integer, ID de recién nacido asociado (FK a gnuhealth_newborn.id)\n  institution: integer, institución de salud (FK a gnuhealth_institution.id)\n  lab_confirmed: boolean, confirmación de laboratorio\n  lab_test: integer, ID de la prueba de laboratorio asociada (FK a gnuhealth_lab.id)\n  est_dodx: boolean, diagnóstico estimado (no confirmado)\n\nllaves_foráneas:\n  pathology       → gnuhealth_pathology(id)\n  healthprof      → gnuhealth_healthprofessional(id)\n  pcs_code        → gnuhealth_procedure(id)\n  name            → gnuhealth_patient(id)\n  newborn_id      → gnuhealth_newborn(id)\n  institution     → gnuhealth_institution(id)\n  lab_test        → gnuhealth_lab(id)\n\níndices:\n  - clave primaria: id\n  - índice: allergy_type\n  - índice: disease_severity\n  - índice: status\n\n Table: party_party\ntabla: party_party\ndescripción: Contiene la información básica de entidades dentro del sistema (personas, instituciones, pacientes, profesionales de salud, aseguradoras, etc.), actuando como base para identificar a cada parte involucrada en procesos clínicos, administrativos o logísticos.\n\ncolumnas:\n  id: integer, clave primaria autoincremental\n  create_date: timestamp, fecha de creación del registro\n  write_date: timestamp, fecha de última modificación\n  create_uid: integer, ID del usuario que creó el registro\n  write_uid: integer, ID del usuario que modificó por última vez\n  code: varchar, código único asignado a la entidad\n  code_length: integer, longitud del código (útil para validaciones)\n  active: boolean, indica si la entidad está activa\n  name: varchar, nombre o denominación principal\n  photo: bytea, fotografía o imagen de la entidad\n  alternative_identification: boolean, si tiene identificaciones alternativas\n  is_healthprof: boolean, indica si es un profesional de la salud\n  insurance_company_type: varchar, tipo de aseguradora si aplica\n  internal_user: integer, usuario interno del sistema (FK a res_user.id)\n  activation_date: date, fecha de activación de la entidad\n  citizenship: integer, país de ciudadanía (FK a country_country.id)\n  is_patient: boolean, indica si es un paciente\n  is_insurance_company: boolean, indica si es una aseguradora\n  ref: varchar, identificador único de persona (PUID)\n  lastname: varchar, apellidos (en caso de personas)\n  ethnic_group: integer, grupo étnico (FK a gnuhealth_ethnicity.id)\n  du: integer, documento único (FK a gnuhealth_du.id)\n  unidentified: boolean, indica si la persona es no identificada\n  dob: date, fecha de nacimiento\n  is_institution: boolean, si es una institución\n  marital_status: varchar, estado civil\n  gender: varchar, género (masculino, femenino, otro)\n  is_pharmacy: boolean, si representa a una farmacia\n  residence: integer, país o lugar de residencia (FK a country_country.id)\n  is_person: boolean, indica si es una persona física\n  education: varchar, nivel educativo\n  occupation: integer, ocupación (FK a gnuhealth_occupation.id)\n  warehouse: integer, almacén asociado (FK a stock_location.id)\n  death_certificate: integer, certificado de defunción (FK a gnuhealth_death_certificate.id)\n  birth_certificate: integer, certificado de nacimiento (FK a gnuhealth_birth_certificate.id)\n  deceased: boolean, si está fallecido\n  name_representation: varchar, nombre en forma alternativa\n  replaced_by: integer, ID de reemplazo (FK a party_party.id)\n  federation_account: varchar, identificador de federación (para interoperabilidad)\n  fed_country: varchar, país de federación\n  fsync: boolean, usado para sincronización federada\n  est_dob: boolean, fecha de nacimiento estimada\n  est_years: integer, edad estimada en años\n  create_target: boolean, indica si debe crearse como objetivo (útil para integración)\n\nllaves_foráneas:\n  internal_user       → res_user(id)\n  citizenship         → country_country(id)\n  ethnic_group        → gnuhealth_ethnicity(id)\n  du                  → gnuhealth_du(id)\n  residence           → country_country(id)\n  occupation          → gnuhealth_occupation(id)\n  warehouse           → stock_location(id)\n  death_certificate   → gnuhealth_death_certificate(id)\n  birth_certificate   → gnuhealth_birth_certificate(id)\n  replaced_by         → party_party(id)\n\níndices:\n  - clave primaria: id\n  - únicos: federation_account, internal_user, ref, code\n  - índices: code, code_length, insurance_company_type, name\n\n\n Table: gnuhealth_pathology\ntabla: gnuhealth_pathology\ndescripción: Catálogo de enfermedades o condiciones médicas. Contiene información estandarizada como el código, nombre, clasificación genética y categoría principal, usada para registrar diagnósticos en los pacientes.\n\nConsideraciones Clave Adicionales para gnuhealth_pathology\nCatálogo de Patologías: La tabla gnuhealth_pathology es un catálogo de todas las posibles enfermedades o condiciones médicas que se pueden diagnosticar.\n\nVínculo con gnuhealth_patient_disease: El campo pathology en gnuhealth_patient_disease es una clave foránea que apunta a gnuhealth_pathology.id. Esto significa que cada registro de diagnóstico de paciente (gnuhealth_patient_disease) está vinculado a una definición de enfermedad (gnuhealth_pathology).\n\nInformación Estandarizada: gnuhealth_pathology contiene el code y name estandarizados de las enfermedades, lo cual es útil para listar o agrupar diagnósticos por su nombre oficial. También tiene un campo active para indicar si la patología está en uso.\n\ncolumnas:\n  id: integer, clave primaria autoincremental\n  create_date: timestamp, fecha de creación del registro\n  write_date: timestamp, fecha de última modificación\n  create_uid: integer, ID del usuario que creó el registro\n  write_uid: integer, ID del usuario que modificó por última vez\n  category: integer, categoría principal de la enfermedad (FK a gnuhealth_pathology_category.id)\n  code: varchar, código de la enfermedad (puede ser estándar como CIE-10, SNOMED, etc.)\n  name: varchar, nombre de la enfermedad o condición\n  info: text, información adicional\n  protein: varchar, proteína relacionada (si aplica)\n  gene: varchar, gen relacionado (si aplica)\n  chromosome: varchar, cromosoma afectado (si aplica)\n  active: boolean, indica si la patología está activa y disponible para ser usada\n  uri: varchar, enlace o identificador externo (por ejemplo, en bases de datos médicas)\n\nllaves_foráneas:\n  category → gnuhealth_pathology_category(id)\n\níndices:\n  - clave primaria: id\n  - índice único: code\n  - índice: active\n\n\n Table: gnuhealth_du\ntabla: gnuhealth_du\ndescripción: Esta tabla contiene información detallada sobre las unidades de vivienda registradas, incluyendo características físicas de la propiedad, ubicación geográfica, servicios básicos disponibles y otros datos sociodemográficos relevantes.\n\ncolumnas:\n  id: integer, clave primaria autoincremental\n  create_date: timestamp, fecha de creación del registro\n  write_date: timestamp, fecha de última modificación\n  create_uid: integer, ID del usuario que creó el registro (FK a res_user.id)\n  write_uid: integer, ID del usuario que modificó por última vez el registro (FK a res_user.id)\n  bathrooms: integer, número de baños en la vivienda\n  roof_type: varchar, tipo de techo (ej. teja, lámina, concreto)\n  urladdr: varchar, enlace al mapa u otro recurso geográfico (ej. OpenStreetMap)\n  sewers: boolean, indica si la vivienda tiene acceso a red de alcantarillado\n  dwelling: varchar, tipo de vivienda (ej. casa, apartamento)\n  address_street_number: varchar, número del inmueble en la calle \n  address_country: integer, país (FK a gcountry_country.id)\n  address_street: varchar, nombre de la calle\n  electricity: boolean, indica si cuenta con suministro eléctrico\n  address_subdivision: integer, subdivisión administrativa (FK a country_subdivision.id)\n  housing: varchar, condiciones o estado de la vivienda\n  address_district: varchar, distrito al que pertenece\n  materials: varchar, materiales predominantes de construcción\n  internet: boolean, indica si cuenta con acceso a internet\n  latitude: numeric, coordenada de latitud de la vivienda\n  address_zip: varchar, código postal\n  picture: bytea, imagen o fotografía asociada a la vivienda\n  address_street_bis: varchar, información adicional del domicilio (bis, etc.)\n  bedrooms: integer, cantidad de dormitorios\n  gas: boolean, indica si tiene acceso a suministro de gas\n  television: boolean, indica si cuenta con televisión\n  telephone: boolean, indica si tiene línea telefónica\n  water: boolean, acceso a agua potable o red pública\n  total_surface: integer, superficie total de la vivienda (en metros cuadrados)\n  desc: varchar, descripción general de la vivienda\n  address_city: varchar, ciudad donde se ubica la vivienda\n  operational_sector: integer, sector operativo asignado (FK a gnuhealth_operational_sector.id)\n  name: varchar, identificador único o código de la vivienda\n  trash: boolean, indica si cuenta con servicio de recolección de basura\n  longitude: numeric, coordenada de longitud\n  address_municipality: varchar, municipio correspondiente\n  altitude: integer, altitud sobre el nivel del mar\n\nllaves_foráneas:\n  address_country     → gcountry_country(id)\n  address_subdivision → country_subdivision(id)\n  operational_sector  → gnuhealth_operational_sector(id)\n\níndices:\n  - clave primaria: id\n  - índices únicos: name\n    \nUserQuestion:Listame un conteo de las enfermedades registradas en los pacietnes, agrupalas por municipio y enfermedad. muestrame un total por municpio y enfermedad.'}
role='assistant' content='```json\n{"require": true, "sql": "SELECT du.desc AS \\"Municipio\\", gp.name AS \\"Enfermedad\\", COUNT(gpd.id) AS \\"Total\\" FROM gnuhealth_patient_disease AS gpd JOIN gnuhealth_patient AS ghp ON gpd.name = ghp.id JOIN gnuhealth_pathology AS gp ON gpd.pathology = gp.id JOIN party_party AS pp ON ghp.name = pp.id JOIN gnuhealth_du AS du ON pp.du = du.id WHERE pp.active = TRUE GROUP BY \\"Municipio\\", \\"Enfermedad\\" ORDER BY \\"Municipio\\", \\"Enfermedad\\""}\n```' thinking=None images=None tool_calls=None
{'role': 'system', 'content': 'You are an SQL expert specialized in the GNU Health database. You are part of an application system. Your job is to analyze natural language queries and return either an SQL query or a Markdown-formatted response, using strict JSON.\n\nYou must always respond in one of the following three valid JSON formats:\n\n---\n\n1. When the user query requires SQL execution:\n{"require": true, "sql": "SQL QUERY HERE"}\n\n- Only use this format when SQL is needed.\n- The query must be correct and based on the GNU Health schema.\n- Do not include explanations.\n- Do not wrap the output in code blocks or quotes.\n- Do NOT use Markdown outside.\n- Return only the JSON object.\n\n---\n\n2. When the user query does not require SQL:\n{"content": "RESPONSE IN MARKDOWN"}\n\n- Use this format to explain, clarify, or answer general questions.\n- Respond using Markdown inside the "content" field.\n- Always respond in the same language the user used.\n- Do not include SQL unless the user asked for it.\n- Do not explain unless requested.\n\nfew-shot-example:\nUserQuestion: puedes revisar cual es el tipo mas comun\n{content:"El analisi muestra que el tipo mas comun es......"}\n\n\n\n---\n\n3. When the SQL query you provided fails and the system returns an error:\n\n{"error": "ERROR MESSAGE HERE"}\n\n- This means your previous SQL query failed.\n- Analyze the error message and respond with either:\na) A corrected SQL query using {"require": true, "sql": "..."}\nb) A Markdown explanation using {"content": "..."} if the error cannot be resolved in SQL.\n- Never return the error message directly to the user.\n- Always follow the same language used by the user.\n- Never break JSON formatting.\n\nExecutedSQL: SELECT gp.name FROM gnuhealth_pathology as gpt LIMIT 50\nSQLError: missing FROM-clause entry for table "gp" Position: 8\n\nrespond:{"require":true, "sql":"SELECT gpt.name FROM gnuhealth_pathology as gpt LIMIT 50"}\n\n---\n\nQuery execution:\n\n- The database engine is PostgreSQL.\n- You do not execute SQL.\n- When you return {"require": true, "sql": "..."}, the system will run the query and return the result to you.\n- The result will be in the following format:\n\n    [\n    {"Column1": "Value1", "Column2": "Value2"},\n    {"Column1": "Value1", "Column2": "Value2"},\n    ...\n    ]\n\n- When you receive the result, respond using:\n{"content": "RESULT IN MARKDOWN"}\n\n- Format the result as a Markdown table if appropriate.\n- Do not generate a new SQL query.\n- Do not explain the data unless the user requested it.\n\n--\n\nParsing issues:\n\n- If you receive a query result that is malformed or cannot be parsed, do not respond with a generic message.\n- Instead, return the following format to signal a data parsing issue:\n\n{"parse_error": "Could not parse the query result. Please check the format or structure."}\n\n- This helps the application detect and handle data parsing errors.\n- Do not use the {"content": "..."} format for this case.\n\n---\n\nMultilingual behavior:\n\n- Match the language of the user in all responses.\n- If the user writes in Spanish, respond in Spanish.\n- If the user writes in English, respond in English.\n\n---\n\nStrict rules:\n\n- Never include reasoning, or extra commentary.\n- Never return invalid JSON.\n- Never return multiple formats at once.\n- Never include code blocks or quotes around the JSON.\n- Follow the context provided by the tables\n\nFew-Shot-Examples:\n\nUserQuestion: listar  las enfermedades \nrespond:{"require":true, "sql":"SELECT gnuhealth_pathology.name FROM gnuhealth_pathology LIMIT 50;"}\n\n\n\n\n\n'}
{'role': 'user', 'content': 'listame un conteo de las enfermedades regsitradas por genero'}
{'role': 'user', 'content': '\n    database context:\n     Table: gnuhealth_patient_disease\ntabla: gnuhealth_patient_disease\ndescripción: Registra los diagnósticos y enfermedades de cada paciente, incluyendo severidad, fechas relevantes, tratamiento, profesional tratante y metadatos clínicos (alergias, infecciosidad, estado, etc.).\n\n\nSe utiliza gnuhealth_patient_disease (gpd) como la tabla central, filtrando por gpd.is_active = TRUE para asegurar que solo se consideren diagnósticos activos.\n\nSe realiza un LEFT JOIN con gnuhealth_patient (gp) usando gpd.name = gp.id para obtener el nombre del paciente (patient_name).\n\nLuego, se hace otro LEFT JOIN con gnuhealth_pathology (gph) utilizando gpd.pathology = gph.id para obtener el nombre estandarizado de la enfermedad (disease_name).\n\nFinalmente, se usa COUNT(gpd.id) y GROUP BY gp.name, gph.name para contar cuántos diagnósticos de una enfermedad específica tiene cada paciente. El ORDER BY ayuda a organizar los resultados.\n\n\nUserQuestion:\n\n"Dame un recuento de este mes sobre las enefermedades registradas"\n\n"Lista los casos de enfermedades registradas"\n\n"realiza un conteo de las enfermedades regsitradas"\n\nRespond: {\n  "require": true,\n  "sql": "SELECT  gph.name AS "Enfermedad", COUNT(gpd.id) AS "total" FROM gnuhealth_patient_disease AS gpd LEFT JOIN gnuhealth_patient AS gp ON gpd.name = gp.id LEFT JOIN gnuhealth_pathology AS gph ON gpd.pathology = gph.id WHERE gpd.is_active = TRUE GROUP BY  gph.name ORDER BY  "total" DESC;"\n  "}\n\n\ncolumnas:\n  id: integer, clave primaria autoincremental\n  create_date: timestamp, fecha de creación del registro\n  write_date: timestamp, fecha de última modificación\n  create_uid: integer, ID del usuario que creó el registro\n  write_uid: integer, ID del usuario que modificó por última vez\n  treatment_description: varchar, descripción del tratamiento administrado\n  healed_date: date, fecha de curación o resolución de la enfermedad\n  pathology: integer, patología diagnosticada (FK a gnuhealth_pathology.id)\n  disease_severity: varchar, severidad de la enfermedad (leve, moderada, grave, etc.)\n  is_allergy: boolean, indica si se trata de una enfermedad alérgica\n  healthprof: integer, profesional de salud responsable (FK a gnuhealth_healthprofessional.id)\n  pregnancy_warning: boolean, advertencia si el diagnóstico afecta el embarazo\n  weeks_of_pregnancy: integer, semana de gestación en la que se contrajo la enfermedad\n  is_on_treatment: boolean, indica si el pacientetabla: gnuhealth_patient_disease\ndescripción: Registra los diagnósticos y enfermedades de cada paciente, incluyendo severidad, fechas relevantes, tratamiento, profesional tratante y metadatos clínicos (alergias, infecciosidad, estado, etc.).\n\n\n\n\n\ncolumnas:\n  id: integer, clave primaria autoincremental\n  create_date: timestamp, fecha de creación del registro\n  write_date: timestamp, fecha de última modificación\n  create_uid: integer, ID del usuario que creó el registro\n  write_uid: integer, ID del usuario que modificó por última vez\n  treatment_description: varchar, descripción del tratamiento administrado\n  healed_date: date, fecha de curación o resolución de la enfermedad\n  pathology: integer, patología diagnosticada (FK a gnuhealth_pathology.id)\n  disease_severity: varchar, severidad de la enfermedad (leve, moderada, grave, etc.)\n  is_allergy: boolean, indica si se trata de una enfermedad alérgica\n  healthprof: integer, profesional de salud responsable (FK a gnuhealth_healthprofessional.id)\n  pregnancy_warning: boolean, advertencia si el diagnóstico afecta el embarazo\n  weeks_of_pregnancy: integer, semana de gestación en la que se contrajo la enfermedad\n  is_on_treatment: boolean, indica si el paciente está actualmente en tratamiento\n  diagnosed_date: date, fecha de diagnóstico\n  extra_info: text, información adicional\n  status: varchar, estado del diagnóstico (activo, resuelto, crónico, etc.)\n  is_active: boolean, indica si la enfermedad está activa\n  date_stop_treatment: date, fecha de fin del tratamiento\n  pcs_code: integer, código de procedimiento (FK a gnuhealth_procedure.id)\n  is_infectious: boolean, indica si la enfermedad es infecciosa\n  allergy_type: varchar, tipo de alergia (alimentaria, medicamentosa, ambiental, etc.)\n  name: integer, paciente (FK a gnuhealth_patient.id)\n  age: integer, edad del paciente al momento del diagnóstico\n  date_start_treatment: date, fecha de inicio del tratamiento\n  short_comment: varchar, comentarios breves\n  newborn_id: integer, ID de recién nacido asociado (FK a gnuhealth_newborn.id)\n  institution: integer, institución de salud (FK a gnuhealth_institution.id)\n  lab_confirmed: boolean, confirmación de laboratorio\n  lab_test: integer, ID de la prueba de laboratorio asociada (FK a gnuhealth_lab.id)\n  est_dodx: boolean, diagnóstico estimado (no confirmado)\n\nllaves_foráneas:\n  pathology       → gnuhealth_pathology(id)\n  healthprof      → gnuhealth_healthprofessional(id)\n  pcs_code        → gnuhealth_procedure(id)\n  name            → gnuhealth_patient(id)\n  newborn_id      → gnuhealth_newborn(id)\n  institution     → gnuhealth_institution(id)\n  lab_test        → gnuhealth_lab(id)\n\níndices:\n  - clave primaria: id\n  - índice: allergy_type\n  - índice: disease_severity\n  - índice: status está actualmente en tratamiento\n  diagnosed_date: date, fecha de diagnóstico\n  extra_info: text, información adicional\n  status: varchar, estado del diagnóstico (activo, resuelto, crónico, etc.)\n  is_active: boolean, indica si la enfermedad está activa\n  date_stop_treatment: date, fecha de fin del tratamiento\n  pcs_code: integer, código de procedimiento (FK a gnuhealth_procedure.id)\n  is_infectious: boolean, indica si la enfermedad es infecciosa\n  allergy_type: varchar, tipo de alergia (alimentaria, medicamentosa, ambiental, etc.)\n  name: integer, paciente (FK a gnuhealth_patient.id)\n  age: integer, edad del paciente al momento del diagnóstico\n  date_start_treatment: date, fecha de inicio del tratamiento\n  short_comment: varchar, comentarios breves\n  newborn_id: integer, ID de recién nacido asociado (FK a gnuhealth_newborn.id)\n  institution: integer, institución de salud (FK a gnuhealth_institution.id)\n  lab_confirmed: boolean, confirmación de laboratorio\n  lab_test: integer, ID de la prueba de laboratorio asociada (FK a gnuhealth_lab.id)\n  est_dodx: boolean, diagnóstico estimado (no confirmado)\n\nllaves_foráneas:\n  pathology       → gnuhealth_pathology(id)\n  healthprof      → gnuhealth_healthprofessional(id)\n  pcs_code        → gnuhealth_procedure(id)\n  name            → gnuhealth_patient(id)\n  newborn_id      → gnuhealth_newborn(id)\n  institution     → gnuhealth_institution(id)\n  lab_test        → gnuhealth_lab(id)\n\níndices:\n  - clave primaria: id\n  - índice: allergy_type\n  - índice: disease_severity\n  - índice: status\n\n Table: gnuhealth_patient\ntabla: gnuhealth_patient\ndescripción: Contiene información médica, social, demográfica y de estilo de vida de los pacientes registrados en GNU Health.\n\nNOTA: Simpre que el usaurio pida realizar algun tipo de conteo asegurate de agrupar por campos relevanates.\n\nGuia de uso:\n\nAlgunas preguntas relacionadas a este documento son:\nEstado Activo: Siempre se debe verificar que el paciente esté activo. La tabla party_party contiene el campo active para esta verificación.\nInformación de Pacientes: La información principal de los pacientes se encuentra en gnuhealth_patient, vinculada a party_party por patient.name = party.id.\nCálculo de Edad: Para la edad, se requiere gnuhealth_patient, party_party y gnuhealth_birth_certificate.\nUbicación (Municipio/Ciudad/Lugar): La ubicación del paciente se obtiene a través de gnuhealth_du (descripción de la unidad de distribución) relacionada con party_party.du.\n\n\n\nPara obtener la ubciacion de un paciente (Municipio, vivienda) usa este SQL\nSQL: SELECT du.desc as "Municipio"  FROM gnuhealth_patient as patient LEFT JOIN party_party as party  on  patient.name = party.id\nLEFT JOIN gnuhealth_du as du ON party.du=du.id WHERE party.active=true\n\nPara saber si un apciente esta activo se ejecuta este SQL\nSQL: SELECT * FROM gnuhealth_patient AS patient LEFT JOIN party_party AS party ON patient.name = party.id WHERE party.active = TRUE;\n\nExplicacion de este query Esta consulta base es esencial para filtrar solo los registros de pacientes que están designados como activos en el sistema, utilizando la columna active de la tabla party_party.\n\nUserQuestion:\n\n"Listar la distribución de los casos por edad."\n"Mostrar un promedio de edad de los pacientes."\n"¿Cuál es la edad de los pacientes?"\nSQL de Promedio de Edad:\nrespond: {\n  "require": true,\n  "sql": "SELECT AVG(DATE_PART(\'year\', AGE(birth.dob))) AS promedio_edad FROM gnuhealth_patient AS patient LEFT JOIN party_party AS party ON patient.name = party.id LEFT JOIN gnuhealth_birth_certificate AS birth ON birth.name = party.id WHERE party.active = TRUE;"\n}\n\nSQL de Distribución por Edad (rangos/individual):\n{\n  "require": true,\n  "sql": "SELECT DATE_PART(\'year\', AGE(birth.dob)) AS edad, COUNT(patient.name) AS total_pacientes FROM gnuhealth_patient AS patient LEFT JOIN party_party AS party ON patient.name = party.id LEFT JOIN gnuhealth_birth_certificate AS birth ON birth.name = party.id WHERE party.active = TRUE GROUP BY edad ORDER BY edad;"\n}\nPara la edad, se usa la función DATE_PART(\'year\', AGE(birth.dob)) combinando gnuhealth_patient, party_party y gnuhealth_birth_certificate. El promedio usa AVG(), y la distribución se logra con COUNT() y GROUP BY sobre la edad calculada.\n\n\nUserQuestion:\n"Listar la distribución de los pacientes por (sexo, género, mujer y hombre)."\n\nrespond:{\n  "require": true,\n  "sql": "SELECT party.gender, COUNT(patient.name) AS total_pacientes FROM gnuhealth_patient AS patient LEFT JOIN party_party AS party ON patient.name = party.id WHERE party.active = TRUE GROUP BY party.gender;"\n}\nEsta consulta utiliza COUNT() y GROUP BY sobre el campo party.gender de la tabla party_party para agrupar y contar pacientes por su género. La condición party.active = TRUE asegura la inclusión solo de pacientes activos.\n\n\nUserQuestion: \n- Muéstrame el recuento de casos de enfermedades por condición de salud (agrupando \'diabetes\' y sus variantes) desglosado por género (masculino y femenino), incluyendo solo pacientes activos. Ordena por el total de casos.",\n- Lista un conteo de las enfermedades y su dstirbucion por( sexo,genero, hombre y mujer)\nrespond:{\n    "require": true,\n    "sql": "SELECT CASE WHEN LOWER(gp.name) LIKE \'%diabetes%\' THEN \'Diabetes\' ELSE gp.name END AS condicion_salud, COUNT(CASE WHEN pp.gender = \'m\' THEN 1 END) AS masculino, COUNT(CASE WHEN pp.gender = \'f\' THEN 1 END) AS femenino, COUNT(gpd.id) AS total_casos FROM gnuhealth_patient_disease AS gpd JOIN gnuhealth_pathology AS gp ON gpd.pathology = gp.id JOIN gnuhealth_patient AS ghp ON gpd.name = ghp.id JOIN party_party AS pp ON ghp.name = pp.id WHERE pp.active = TRUE GROUP BY condicion_salud ORDER BY total_casos DESC;"\n}\n  "Explicacion": "Esta consulta agrupa los diagnósticos de enfermedades. Utiliza un `CASE` para normalizar todas las variantes de \'diabetes\' a una sola categoría \'Diabetes\'. Luego, cuenta los casos para hombres y mujeres por separado usando `COUNT(CASE WHEN ... THEN 1 END)`, y un conteo total de casos por cada condición. Se unen las tablas `gnuhealth_patient_disease`, `gnuhealth_pathology`, `gnuhealth_patient` y `party_party`. La condición `pp.active = TRUE` asegura que solo se consideren pacientes activos. Los resultados se agrupan por la condición de salud y se ordenan por el total de casos de forma descendente."\n\n\n\ncolumnas:\n  id: integer, clave primaria autoincremental\n  create_date: timestamp, fecha de creación del registro\n  write_date: timestamp, fecha de última modificación\n  create_uid: integer, ID del usuario que creó el registro\n  write_uid: integer, ID del usuario que modificó por última vez\n  family: integer, ID de la familia del paciente (FK a gnuhealth_family.id)\n  blood_type: varchar, tipo de sangre del paciente\n  general_info: text, información médica general\n  primary_care_doctor: integer, médico de cabecera (FK a gnuhealth_healthprofessional.id)\n  critical_info: text, información crítica adicional\n  rh: varchar, factor Rh del paciente\n  current_address: integer, dirección temporal (FK a party_address.id)\n  name: integer, ID del paciente (FK a party_party.id)\n  dod: timestamp, fecha de fallecimiento\n  current_insurance: integer, aseguradora actual (FK a gnuhealth_insurance.id)\n  cod: integer, causa de muerte (FK a gnuhealth_pathology.id)\n  deceased: boolean, indica si el paciente ha fallecido\n  works_at_home: boolean, indica si trabaja desde casa\n  prison_current: boolean, indica si está actualmente en prisión\n  domestic_violence: boolean, ha sido víctima de violencia doméstica\n  hostile_area: boolean, vive en zona de riesgo o conflicto\n  sexual_abuse: boolean, ha sufrido abuso sexual\n  hours_outside: integer, horas promedio fuera del hogar por día\n  drug_addiction: boolean, adicción activa a drogas\n  school_withdrawal: boolean, abandono escolar\n  income: varchar, nivel de ingresos del paciente\n  single_parent: boolean, vive en familia monoparental\n  ses_notes: text, notas adicionales sobre situación socioeconómica\n\nllaves_foráneas:\n  family → gnuhealth_family(id)\n  primary_care_doctor → gnuhealth_healthprofessional(id)\n  current_address → party_address(id)\n  name → party_party(id)\n  current_insurance → gnuhealth_insurance(id)\n  cod → gnuhealth_pathology(id)\n  diet_belief → gnuhealth_diet_belief(id)\n  vegetarian_type → gnuhealth_vegetarian_types(id)\n\níndices:\n  - clave primaria: id\n  - única: name\n  - índice adicional: active\n\n Table: gnuhealth_pathology\ntabla: gnuhealth_pathology\ndescripción: Catálogo de enfermedades o condiciones médicas. Contiene información estandarizada como el código, nombre, clasificación genética y categoría principal, usada para registrar diagnósticos en los pacientes.\n\nConsideraciones Clave Adicionales para gnuhealth_pathology\nCatálogo de Patologías: La tabla gnuhealth_pathology es un catálogo de todas las posibles enfermedades o condiciones médicas que se pueden diagnosticar.\n\nVínculo con gnuhealth_patient_disease: El campo pathology en gnuhealth_patient_disease es una clave foránea que apunta a gnuhealth_pathology.id. Esto significa que cada registro de diagnóstico de paciente (gnuhealth_patient_disease) está vinculado a una definición de enfermedad (gnuhealth_pathology).\n\nInformación Estandarizada: gnuhealth_pathology contiene el code y name estandarizados de las enfermedades, lo cual es útil para listar o agrupar diagnósticos por su nombre oficial. También tiene un campo active para indicar si la patología está en uso.\n\ncolumnas:\n  id: integer, clave primaria autoincremental\n  create_date: timestamp, fecha de creación del registro\n  write_date: timestamp, fecha de última modificación\n  create_uid: integer, ID del usuario que creó el registro\n  write_uid: integer, ID del usuario que modificó por última vez\n  category: integer, categoría principal de la enfermedad (FK a gnuhealth_pathology_category.id)\n  code: varchar, código de la enfermedad (puede ser estándar como CIE-10, SNOMED, etc.)\n  name: varchar, nombre de la enfermedad o condición\n  info: text, información adicional\n  protein: varchar, proteína relacionada (si aplica)\n  gene: varchar, gen relacionado (si aplica)\n  chromosome: varchar, cromosoma afectado (si aplica)\n  active: boolean, indica si la patología está activa y disponible para ser usada\n  uri: varchar, enlace o identificador externo (por ejemplo, en bases de datos médicas)\n\nllaves_foráneas:\n  category → gnuhealth_pathology_category(id)\n\níndices:\n  - clave primaria: id\n  - índice único: code\n  - índice: active\n\n\n Table: party_party\ntabla: party_party\ndescripción: Contiene la información básica de entidades dentro del sistema (personas, instituciones, pacientes, profesionales de salud, aseguradoras, etc.), actuando como base para identificar a cada parte involucrada en procesos clínicos, administrativos o logísticos.\n\ncolumnas:\n  id: integer, clave primaria autoincremental\n  create_date: timestamp, fecha de creación del registro\n  write_date: timestamp, fecha de última modificación\n  create_uid: integer, ID del usuario que creó el registro\n  write_uid: integer, ID del usuario que modificó por última vez\n  code: varchar, código único asignado a la entidad\n  code_length: integer, longitud del código (útil para validaciones)\n  active: boolean, indica si la entidad está activa\n  name: varchar, nombre o denominación principal\n  photo: bytea, fotografía o imagen de la entidad\n  alternative_identification: boolean, si tiene identificaciones alternativas\n  is_healthprof: boolean, indica si es un profesional de la salud\n  insurance_company_type: varchar, tipo de aseguradora si aplica\n  internal_user: integer, usuario interno del sistema (FK a res_user.id)\n  activation_date: date, fecha de activación de la entidad\n  citizenship: integer, país de ciudadanía (FK a country_country.id)\n  is_patient: boolean, indica si es un paciente\n  is_insurance_company: boolean, indica si es una aseguradora\n  ref: varchar, identificador único de persona (PUID)\n  lastname: varchar, apellidos (en caso de personas)\n  ethnic_group: integer, grupo étnico (FK a gnuhealth_ethnicity.id)\n  du: integer, documento único (FK a gnuhealth_du.id)\n  unidentified: boolean, indica si la persona es no identificada\n  dob: date, fecha de nacimiento\n  is_institution: boolean, si es una institución\n  marital_status: varchar, estado civil\n  gender: varchar, género (masculino, femenino, otro)\n  is_pharmacy: boolean, si representa a una farmacia\n  residence: integer, país o lugar de residencia (FK a country_country.id)\n  is_person: boolean, indica si es una persona física\n  education: varchar, nivel educativo\n  occupation: integer, ocupación (FK a gnuhealth_occupation.id)\n  warehouse: integer, almacén asociado (FK a stock_location.id)\n  death_certificate: integer, certificado de defunción (FK a gnuhealth_death_certificate.id)\n  birth_certificate: integer, certificado de nacimiento (FK a gnuhealth_birth_certificate.id)\n  deceased: boolean, si está fallecido\n  name_representation: varchar, nombre en forma alternativa\n  replaced_by: integer, ID de reemplazo (FK a party_party.id)\n  federation_account: varchar, identificador de federación (para interoperabilidad)\n  fed_country: varchar, país de federación\n  fsync: boolean, usado para sincronización federada\n  est_dob: boolean, fecha de nacimiento estimada\n  est_years: integer, edad estimada en años\n  create_target: boolean, indica si debe crearse como objetivo (útil para integración)\n\nllaves_foráneas:\n  internal_user       → res_user(id)\n  citizenship         → country_country(id)\n  ethnic_group        → gnuhealth_ethnicity(id)\n  du                  → gnuhealth_du(id)\n  residence           → country_country(id)\n  occupation          → gnuhealth_occupation(id)\n  warehouse           → stock_location(id)\n  death_certificate   → gnuhealth_death_certificate(id)\n  birth_certificate   → gnuhealth_birth_certificate(id)\n  replaced_by         → party_party(id)\n\níndices:\n  - clave primaria: id\n  - únicos: federation_account, internal_user, ref, code\n  - índices: code, code_length, insurance_company_type, name\n\n\n Table: gnuhealth_du\ntabla: gnuhealth_du\ndescripción: Esta tabla contiene información detallada sobre las unidades de vivienda registradas, incluyendo características físicas de la propiedad, ubicación geográfica, servicios básicos disponibles y otros datos sociodemográficos relevantes.\n\ncolumnas:\n  id: integer, clave primaria autoincremental\n  create_date: timestamp, fecha de creación del registro\n  write_date: timestamp, fecha de última modificación\n  create_uid: integer, ID del usuario que creó el registro (FK a res_user.id)\n  write_uid: integer, ID del usuario que modificó por última vez el registro (FK a res_user.id)\n  bathrooms: integer, número de baños en la vivienda\n  roof_type: varchar, tipo de techo (ej. teja, lámina, concreto)\n  urladdr: varchar, enlace al mapa u otro recurso geográfico (ej. OpenStreetMap)\n  sewers: boolean, indica si la vivienda tiene acceso a red de alcantarillado\n  dwelling: varchar, tipo de vivienda (ej. casa, apartamento)\n  address_street_number: varchar, número del inmueble en la calle \n  address_country: integer, país (FK a gcountry_country.id)\n  address_street: varchar, nombre de la calle\n  electricity: boolean, indica si cuenta con suministro eléctrico\n  address_subdivision: integer, subdivisión administrativa (FK a country_subdivision.id)\n  housing: varchar, condiciones o estado de la vivienda\n  address_district: varchar, distrito al que pertenece\n  materials: varchar, materiales predominantes de construcción\n  internet: boolean, indica si cuenta con acceso a internet\n  latitude: numeric, coordenada de latitud de la vivienda\n  address_zip: varchar, código postal\n  picture: bytea, imagen o fotografía asociada a la vivienda\n  address_street_bis: varchar, información adicional del domicilio (bis, etc.)\n  bedrooms: integer, cantidad de dormitorios\n  gas: boolean, indica si tiene acceso a suministro de gas\n  television: boolean, indica si cuenta con televisión\n  telephone: boolean, indica si tiene línea telefónica\n  water: boolean, acceso a agua potable o red pública\n  total_surface: integer, superficie total de la vivienda (en metros cuadrados)\n  desc: varchar, descripción general de la vivienda\n  address_city: varchar, ciudad donde se ubica la vivienda\n  operational_sector: integer, sector operativo asignado (FK a gnuhealth_operational_sector.id)\n  name: varchar, identificador único o código de la vivienda\n  trash: boolean, indica si cuenta con servicio de recolección de basura\n  longitude: numeric, coordenada de longitud\n  address_municipality: varchar, municipio correspondiente\n  altitude: integer, altitud sobre el nivel del mar\n\nllaves_foráneas:\n  address_country     → gcountry_country(id)\n  address_subdivision → country_subdivision(id)\n  operational_sector  → gnuhealth_operational_sector(id)\n\níndices:\n  - clave primaria: id\n  - índices únicos: name\n    \nUserQuestion:listame un conteo de las enfermedades regsitradas por genero'}
role='assistant' content='```json\n{\n  "require": true,\n  "sql": "SELECT party.gender, COUNT(gpd.id) AS total_casos FROM gnuhealth_patient_disease AS gpd JOIN gnuhealth_pathology AS gph ON gpd.pathology = gph.id JOIN gnuhealth_patient AS patient ON gpd.name = patient.name JOIN party_party AS party ON patient.name = party.id WHERE party.active = TRUE GROUP BY party.gender;"\n}\n```' thinking=None images=None tool_calls=None